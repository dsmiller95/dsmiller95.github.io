---
title: A General approach to testing grid-based games
tags: [tooling, unity, tdd]
date: 2024-04-25T00:00:00.000Z
path: blog/tdd-grid-games
cover: ./preview.png
excerpt: An approach to writing tests in a highly adaptable way for grid-based games
author: Dan Miller
hidden: true
---

# Outline

- [Overview](#overview)
- [Map Layout string](#map-layout-string)
  - [Goal](#map-goal)
  - [Implementation](#map-implementation)
    - [Parser](#parser)
    - [Axis transformer](#axis-transformer)
    - [Lookup table](#lookup-table)
- [Command pattern](#command-pattern)
  - [Command Goal](#command-goal)
  - [Command Implementation](#command-implementation)
    - [The Interfaces](#the-interfaces)
    - [The Implementation](#the-implementation)
    - [Aside - benefits of Commands in the game](#aside---benefits-of-commands-in-the-game)
- [Tying it all together](#tying-it-all-together)
  - [The TDD Workflow](#the-tdd-workflow)
  - [When not to use](#when-not-to-use)
- [Conclusion](#conclusion)

# Overview

I want to share a game development technique I've repeated across two game jams (so far!), and I hope you find it useful too! Specifically, we will be driving game logic by writing tests first. In general this approach is specialized for "grid-based" games. For example, these are all "grid-based" games: Chess, Connect 4, Tetris, Sokoban, [Baba Is You](https://store.steampowered.com/app/736260/Baba_Is_You/), [Into the Breach](https://store.steampowered.com/app/590380/Into_the_Breach/), [Tiny Epic Tactics](https://boardgamegeek.com/boardgame/272409/tiny-epic-tactics), or the two games I've made with this approach: [Disconnect, a riff on connect 4](https://spikedevelops.itch.io/disconnect) and [Gobbies Stole my Ruins, a puzzle dungeon crawler](https://limeblossomjams.itch.io/gobbies-stole-my-ruins) .

The logic of grid-based games is a delight to work with due to the simplicity of the domain. Every object has an exact location and interactions between objects can be precisely defined. Most importantly, the state of the game is easily represented in a 2D or 3D array. With a concise way to create an array, we can build and assert the entire world.

The purpose of this blog post is to keep track of my own thoughts and share them with you. I'd like to turn this approach into a more reusable package and potentially release it as FOSS, so I welcome any feedback on potential footguns I could be walking into here.

First, we'll walk through the two greatest components of this testing paradigm: a highly readable layout string, and a command pattern to interact with the game state. Then I'll close out with a real-world test case from "Gobbies Stole my Ruins" and guidlines for games which will benefit the most from this approach.

# Map Layout String

The map layout string is designed to be a readable representation of a whole game map in one string. Ideally this makes our tests easy to read and simple to maintain.

## Map Goal

We need to map every character of a string into a single tile in the 3D grid. I chose to lay them out in horizontal slices and stack up the horizontal slices to get a full 3D world: imagine MRI data or the a 3D printing slicer to visualize this. The left-most rectangular slice is the bottom slice and the right-most is the top slice. `X` is a block, `-` is empty space, and `P` is the player character. Here's an example of a string layout. The video is an attempt to visualize the transformation the string will go through to become a 3D world.

```
XXX XXX ---
XXX --- ---
XXX -P- ---

//   N
// W x E
//   S
```

import layout_anim from "./level_layout_anim.mp4";

<Video src="./level_layout_anim.mp4" caption="Transforming a layered string into 3D space" ></Video>

We need two utility functions to use this format in our tests. First, a `CreateWorld` function builds a game world from the layout string. Second, an `AssertWorldMatches` function asserts the world against a given layout string. For many of the movement-related tests this is the only assertion we need! As a demonstration of value, compare the following examples. Which do you find easier to reason about?

```csharp
[Test]
void TestPlayerMovesForward_ThenIsBlocked_WithLayout() {
  var map = @"
XXX -X-
XXX ---
XXX -P-
";
  World world = CreateWorld(map);
  /* ... move player forward ... */
  AssertWorldMatches(world, @"
XXX -X-
XXX -P-
XXX ---
");
  /* ... move player forward again ... */
  AssertWorldMatches(world, @"
XXX -X-
XXX -P-
XXX ---
");
}

[Test]
void TestPlayerMovesForward_ThenIsBlocked_WithoutLayout() {
  var world = CreateWorld(new Vector3Int(3, 2, 3));
  world.PlaceFloor();
  world.PlaceWall(new Vector3Int(1, 1, 2));
  world.PlacePlayer(new Vector3Int(1, 1, 0));
  /* ... move player forward ... */
  AssertPlayerPosition(world, new Vector3Int(1, 1, 1));
  /* ... move player forward again ... */
  AssertPlayerPosition(world, new Vector3Int(1, 1, 1));
}
```


If you're still not convinced, consider what the test fails with:

```
Expected:
XXX -X-
XXX -P-
XXX ---

Actual:
XXX -X-
XXX ---
XXX -P-
```

Versus:

```
Expected player at (1, 1, 1), instead found (1, 1, 0)
```

The difference here isn't extreme but will scale well when multiple moving entities are asserted at once.

## Map Implementation

The map layout string can be built from a few components strung together. First we must parse the string into a 3D array with some knowne axis alignment. Then, we transform the axises of this 3D array to match the axis system of the world we are generating. Finally we need a way to turn a single character into something at a given position inside the game world: we'll use a lookup dictionary of game entity factories, keyed by `char`. 

### Parser

The parser is a series of successive string Split operations, splitting by newline first, then the Space separating the y-layers from each other, and finally splitting the string into its individual character components.

```csharp
char[][][] ParseLayoutString(string layoutString){
  string[]   byLine = layoutString.Split("\n");
  string[][] byLineThenLayer = byLine
    .Select(line => 
      line.Split(" ")
    ).ToArray();
  
  char[][][] byLineThenLayerThenChar = byLineThenLayer
    .Select(line => 
      line.Select(lineLayer => 
        lineLayer.ToCharArray()
      ).ToArray();
    ).ToArray();
  
  return byLineThenLayerThenChar;
}
```

Done! Before we move on, consider the indexes we need to access the `i` character in this layout:

```
abc def gih
jkl mno pqr
stu vwx yz0
```

Its indexed by line first, then by each layer in the line, then by the character order inside each segment. Therefore, `charArray[0][2][1] == 'i'`. This definitely isn't in x, y, z order. Ideally we'd access it at the (x, y, z) position of (1, 2, 2).

### Axis transformer

So we'd like to get an array we can access with Unity's axis layout, in (x, y, z) order. We could use unity's Matrix4x4 to do this, but I decided to home bake a utility specifically for re-ordering and flipping axises. Either way will work. This is roughly how we'll get the layout we need:

```csharp
Array3D<char> TransformLayout(Array3D<char> input) {
  DimensionalityTransform transformation = GetDefaultCoordinateTransform();

  var newLayoutSize = transformation.Transform(input.GetSize());
  var output = new Array3D<char>(size: newLayoutSize);

  foreach (var outputCoordinate in AllCoordinatesInside(newLayoutSize)) {
    var inputCoordinate = transformation.InverseTransform(outputCoordinate);

    var inputTile = input[inputCoordinate];
    output[outputCoordinate] = inputTile;
  }

  return output;
}
```

For this specific layout we want our DimensionalityTransform to look something like this: `[-Z][+Y][+X]` . This will end up with a layout where:
- Z points up (lines are ordered from top down, so we need to invert)
- X points left (char arrays are already ordered left to right)
- Y points right across the layers (Layer `Y+1` will be to the right of layer `Y`)

Laid out on a 2x2x2 grid, these are the Z, X, and Y coordinate values at every point:

```
Z
11 11
00 00

X
01 01
01 01

Y
00 11
00 11
```

### Lookup table

From here, we need to take a single character and then create one or more entities at that character's location. In C#, we use the `Func<>` type to wrap up a factory type for us, and bake in the assumption that every tile will have at most one entity in it. So we'll build a `Dictionary<char, Func<Vector3Int, IEntity>>` , and invoke the Factory `Func<>` based on the character found at each position in the entire map. With code:

```csharp
World BuildWorld(
  Array3D<char> xyzLayout,
  Dictionary<char, Func<Vector3Int, IEntity>> tileFactories) 
{
  World world = new World(xyzLayout.Size);

  foreach (Vector3Int coordinate in AllCoordinatesInside(xyzLayout.Size))
  {
    char atLocation = xyzLayout[coordinate];
    Func<Vector3Int, IEntity> factoryFunction = tileFactories[atLocation];

    IEntity createdEntity = factoryFunction(coordinate);
    world = world.AddEntity(createdEntity);
  }

  return world;
}

Dictionary<char, Func<Vector3Int, IEntity>> GetDefaultFactories()
{
  return new Dictionary<char, Func<Vector3Int, IEntity>>()
  {
    {'X', CreateWall   },
    {'P', CreatePlayer },
  }

}
IEntity CreatePlayer(Vector3Int location) { /* ... */ }
IEntity CreateWall  (Vector3Int location) { /* ... */ }
```

We can chain these 3 components together to create our world builder! Then to create the world assertion function we can supplement the factory functions. For my purposes I use a hard type-check: a `P` character will verify there is an entity at that position of exact type `Player`. The assertion function is similar to the world building function, but in reverse. Instead of building the world from a string I build a string from the world based on type-checking entities at each position. Then I assert the built string is equal to the expected string. This isn't the only way to build the assertion function, but it does help to get us the easy to read test assertion failure messages mentioned earlier.

As the implementation changes we can attach more complex assertions to those characters, in the same way that we attach factory functions to them. For example asserting based on a string tag match or the presence of a specific interface implementation. In Gobbies Stole My Ruins, Pickup items are represented by the same parent class, but the parent class contains the item to be picked up. So when we see a Pickup type in a cell, we actually assert against the type of the item *inside* the pickup. In the future we could change this implementation detail again without modifying the tests themselves, only the test harness assertions.

This gives us all the tools we need to build our world from a layout string and assert against it. To adapat this approach into any grid-based game we need access to a couple functions on our game world:
1. Create an entity at a specific grid location, when building the world
2. Get entities at a specific grid location, when asserting agains the world.

Any implementation of a game world which supports those functions will work. In theory we could even use this with GameObjects as long as they were kept at grid-aligned positions!

# Command Pattern

Another useful component of these tests is the command pattern with immutable objects. To some degree this is optional, but I believe that these approaches fit together very well in practice. The command pattern helps manage the entry-points into the system; games with smaller interfaces wouldn't need to go this far. The story is similar for usage of immutability. There is significant developement and performance overhead to implementing immutable data structures. But immutability forces many good practices which pay off when building something complex.

I'll demonstrate some of these advantages via examples as best I can. We'll focus on the command pattern since immutability is less relevant to the tests themselves and more about how the code under test is arranged.


## Command Goal

The command pattern will isolate our tests from most changes in our game logic. We would like to reference only a Factory and the ICommand interface in place of references to any part of the game entities. I'll start with a comparitive example:

```csharp
[Test]
void TestPlayerMovesForward_WithCommands() {
  World world = /* ... create world ... */;
  EntityId playerId = world.GetSingleAt(new Vector3Int(1, 1, 0));
  ICommand moveForwardCommand = CommandFactory.MoveForward(playerId, 1);
  world = world.ApplyCommand(moveForwardCommand);
  /* ... assert movement occurred ... */
}

[Test]
void TestPlayerMovesForward_WithoutCommands() {
  World world = /* ... create world ... */;
  EntityId playerId = world.GetSingleAt(new Vector3Int(1, 1, 0));
  Player player = world.GetEntity<Player>(playerId);
  player.MoveForward(1);
  /* ... assert movement occurred ... */
}
```


Note that the tests which rely on Commands have no references to `Player` or even a `IMove` interface. The test case depends on shared types: `World`, `EntityId`, and `ICommand`. As well as components of the test harness via `CommandFactory`. The command-based tests is isolated from the game implementation which indicates that this test case is more maintainable.

## Command Implementation

To set up our command pattern we will start with a foundation of various interfaces. The implementation itself becomes much clearer after we define the interfaces we're working with.

### The Interfaces

The interfaces describe how the command's implementation interacts with the world and how the world will execute any command:

```csharp
interface IWorldWriter {
  // The command makes changes to the world
  void SetEntity(EntityId id, IEntity newEntity);

  // The command needs data about the world
  IEntity GetEntity(EntityId id);
  IPathingWorld GetPathingData();
}
interface IPathingWorld {
  bool IsBlocked(Vector3Int position);
}
interface IHavePosition {
  Vector3Int GetPosition();
  // The command creates modified immutable copies of entities
  IEntity WithPosition(Vector3Int newPosition);
}
interface IEntity {}

// The world needs a simple interface to execute the command
interface ICommand {
  void Execute(IWorldWriter writer);
}
```

### The Implementation

Now we can implement our command. The `MoveForwardCommand` holds all the logic related to moving and being blocked by walls.

```csharp
class MoveForwardCommand : ICommand {
  public int distance;
  public EntityId targetEntityId;
  public void Execute(IWorldWriter worldWriter) {
    IEntity targetEntity = worldWriter.GetEntity(targetEntityId);
    IHavePosition entityWithPosition = targetEntity as IHavePosition;
    if (entityWithPosition == null) throw new InvalidOperationException("Attempted to move an entity which does not have a position");

    IPathingWorld pathData = worldWriter.GetPathingData();
    Vector3Int currentPosition = entityWithPosition.GetPosition();

    Vector3Int newPosition = MoveForwardFrom(currentPosition, pathData);

    IEntity newEntity = entityWithPosition.WithPosition(newPosition);
    worldWriter.SetEntity(targetEntityId, newEntity);
  }
  private Vector3Int MoveForwardFrom(Vector3Int position, IPathingWorld pathing) {
    /* ... implement moving forward, blocked by walls, this.distance steps ... */
  }
}
```

Anything could be inside this command depending on the game's specific implementation. Importantly an instance is constructed from only very basic types: an `int` and a custom `EntityId` type. All of the commands should be constructed from simple data-only serializable types such as this in order to reap the various benefits that come with using commands.

### Aside - benefits of Commands in the game

Lets have a brief look at what commands do for the game outside of tests. In this example we use commands to represent user input rather than making method calls inside the input manager itself! This allowed us to trivially implement input queuing by queuing the commands and waiting for the previous command to complete before executing the next command.

```csharp
class InputManager: MonoBehavior{
  private World _world;          // set on Start
  private EntityId _playerId;    // set after world initialization
  private KeyCode _dashKey = KeyCode.Shift;
  private KeyCode _stepKey = KeyCode.W;
  private Queue<ICommand> _queuedCommands;
  void Update() {
    var inputCommand = GetInputCommand();
    if (inputCommand != null) {
      _queuedCommands.Enqueue(inputCommand);
    }

    if (_world.IsUpdating && _queuedCommands.Count > 0){
      ICommand nextCommand = _queuedCommands.Dequeue();
      _world = _world.ApplyCommand(nextCommand);
    }
  }

  ICommand? GetInputCommand() {
    if (Input.KeyDown(this._dashKey)) {
      return new MoveForwardCommand() {
        distance = 2,
        targetEntityId = this._playerId
      };
    }
    if (Input.KeyDown(this._stepKey)) {
      return new MoveForwardCommand() {
        distance = 1,
        targetEntityId = this._playerId
      };
    }
    return null;
  }
}
```

Many features are unlocked by serializable commands, including:
- Input queueing
- Passing commands over the network
- Saving commands in a local file
- Replaying a recorded series of commands to acheive identical world state
- Inspecting commands in other parts of the system with listeners. For example, triggering a sword animation after an AttackCommand listener triggered

# Tying it all together

To tie together the map layout and commands, I'll use a real-world test right out of Gobbies Stole My Ruins (with added comments):

```csharp
[Test]
public void WhenPlayerJumps_ThenDashesOverGap_MovesOverGap()
{
    // arrange
    var map = @"
XXX XXX ---
XXX --- ---
XXX -P- ---
";
    CreateWorld(map);
    // places the dash and jump items into the players inventory
    EnableDash();
    EnableJump();
    // search the world for a singleton entity of type Player
    EntityId playerId = GetSingle<Player>();
    // construct a set of commonly used commands bound to the player id
    var mv = new MovementCommands(playerId);
    
    // act + assert
    World = World
        .ApplyCommandsAndTick(mv.jump);
    AssertWorldMatches(@"
XXX XXX ---
XXX --- ---
XXX --- -P-
");
    
    World = World
        .ApplyCommandsAndTick(mv.dash);
    AssertWorldMatches(@"
XXX XXX -P-
XXX --- ---
XXX --- ---
");
}
```

So this is what we get by combining all these techniques together. In my opinion this is everything we need it to be:
- Highly maintainable. The test has no direct dependencies on implementation details
  - except for the `GetSingle<Player>` function call. This is allowed for convenience, and is isolated well enough that it could be replaced en-masse via a regex replacement action.
- Easy to read thanks to the map layout strings


## The TDD Workflow

Lets walk through what a typical update to the application logic would look like, from a TDD perspective. We will be adding combat to the game! The player can attack, and when they do they kill the enemy directly in front of them. If the player doesn't attack then the enemey will instead attack them, killing the player.

First, we write the test:

```csharp

[Test]
public void WhenPlayerAttacks_KillsEnemy()
{
    // arrange
    var map = @"
XXX -E-
XXX -P-
";
    CreateWorld(map);
    EntityId playerId = GetSingle<Player>();
    var mv = new MovementCommands(playerId);
    
    // act + assert
    World = World
        .ApplyCommandsAndTick(mv.attackForward);
    AssertWorldMatches(@"
XXX ---
XXX -P-
");
}

[Test]
public void WhenPlayerIsHit_Dies()
{
    // arrange
    var map = @"
XXX -E-
XXX -P-
";
    CreateWorld(map);
    EntityId playerId = GetSingle<Player>();
    var mv = new MovementCommands(playerId);
    
    // act + assert
    World = World
        .ApplyCommandsAndTick(mv.noop);
    AssertWorldMatches(@"
XXX -E-
XXX ---
");
}
```

This test will not compile right away `mv.attackForward` is a new field and not implemented yet. So first we need to add an Attacking command factory:

```csharp
public static class CommandFactory {
  /* ... */
  public static ICommand AttackForward(EntityId id) {
    return NoopCommand();
  }
}
public class MovementCommands {
  /* ... */
  public ICommand attackForward;
  public MovementCommands(EntityId entityId){
    /* ... */
    attackForward = CommandFactory.AttackForward(entityId);
  }
}
```

At this point, our test is complete: compiling, executing, and failing. The implementation work will involve creating the AttackForwardCommand implementation, and implementing enemies attacking adjacent players. In the course of the implementation we'll replace the contents of the CommandFactory.AttackForward function as well.

I used this workflow extensively when developing Gobbies Stole My Ruins. My teammate would tell me "wouldn't it be neat if dash allowed you to move over open air, instead of stopping at the first ledge?" . Then I would immediately write the test. If I was working on something already, I would mark the test with a comment, ex:
```csharp
// [Test] TODO Ignored: Until dash off ledge
```
Now I know I have that feature documented and can switch back to working on what I was before. Later on, I will look through all the ignored test cases, and pick one to uncomment and begin implementing. Sometimes this is linked to our github issues board, sometimes not.

The important part is that I can document the feature request in a well-defined way pretty much immediately and without too much interruption in flow. And implementing features is entirely contained in the code editor with rigidly defined requirements. I find this makes it very easy to stay focused.

## When not to use

This approach may only work well for specific types of games. The article is about grid-based games for a reason: typically, grid games are totally predictable or can be made to be entirely deterministic. These are the general requirements I imagine a game must have in order to fit into this test harness:

- Deterministic
  - The game must run the exact same way every time from the same starting conditions
  - If randomness is used it must be based on a random seed such that supplying the same seed results in the same sequence of events
- Grid-aligned
  - Everything under test must align to 2D or 3D grid positions, at creation time and at assertion time
  - This is a looser requirement. We can always round positions to the nearest grid position but this could make our tests flaky.

Consider how we could make Chess fit into this framework. It is an ideal candidate since every game piece occupies a grid square. Every change to the game state is a movement of one piece from one grid square to another grid square. The chess community has already started using a standard format for commands, too: [Algebraic notation (chess)](https://en.wikipedia.org/wiki/Algebraic_notation_(chess)) (For example, `Be5` bishop moves to e5). We could start writing tests using this command format before we implemented any part of the chess engine at all!

What if we wanted to test something like Minecraft? Minecraft's blocks are all Grid-aligned but the player character is allowed to walk around freely! The zombies and item pickups are also allowed to float free from the grid. Certainly we can say that the player and items are "inside" a certain cube coordinate, but the game will play differently depending on where exactly they are inside that cube. Therefore could easily test the blocks' interactions but would have trouble testing the players or mobs in the same way. Of course we could use our method the blocks' logic alone, but there are edge cases!

For example, minecraft sand will turn into a free-falling entity when falling. While falling a TNT blast will send it flying on a new trajectory. How would we test that? It would be possible with this method but would depend on precise timing and implementation details of the physics engine. We must consider if the test harness will save us enough time to make up for exceptions to the rule like this.

For a game like Overwatch this testing approach is completely untenable. Every timestep movement is both tiny in distance **and** gameplay relevant, there's no grid, and everything is highly reliant on implementation details of the physics engine. It may be possible to build a harness that uses the command pattern to represent player moves at best. But any attempt to constrain movement and actions to a grid will be so far from typical gameplay that it would be nearly useless.

# Conclusion

Thanks for reading, if you have any feedback I'd love to hear it! I am building a shareable library around these concepts, please have a look if you'd like to dig deeper. Or contribute to the project if you find it useful! See the open-source project here: [link to github](https://github.com/dsmiller95/GridGameTools/blob/main/Assets/Packages/com.dman.grid-game-tools/README.md)