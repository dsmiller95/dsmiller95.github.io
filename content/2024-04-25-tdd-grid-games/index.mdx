---
title: A General approach to testing grid-based games
tags: [tooling, unity, tdd]
date: 2024-04-25T00:00:00.000Z
path: blog/tdd-grid-games
cover: ./preview.png
excerpt: An approach to writing tests in a highly adaptable way for grid-based games
author: Dan Miller
hidden: true
---

# Outline

- Overview
- Map Layout string
  - Goal
  - Implementation
- Command pattern
  - Goal
  - Implementation
- tying it all together


# Overview

I've built a couple grid-based games during game jams at this point. They are a delight to work with due to the simplicity of the domain. Because every object has an exact location, then interactions between objects can be precisely defined. And the state of the world can be easily represented and/or stored in something akin to a 2 or 3D array.

First, I will talk through what my ideal test case should look like. Then, I'll go through the steps needed to attach that test case to a grid-based game, and best practices to build games which work with this technique. These techniques have emerged during my development of grid-based games, for example: TODO link to gobbies and disconnect. 


# Map Layout String

The map layout string is designed to be a readable representation of the geometry of a whole map in one string. Ideally this will make our tests easy to read and simple to maintain.

## Goal

We want to map every character of the string into a single tile in the 3D grid. We can lay them out in horizontal slices then stack up the horizontal slices to get a full 3D world: similar to MRI data or the output of a 3D printing slicer. The left-most slice is the bottom slice and the right-most is the top slice. `X` is a block, `-` is empty space, and `P` is the player character. Here's an example of a string and what the world generated by the string would look like:

```
XXX XXX ---
XXX --- ---
XXX -P- ---
```

![level layout](test_level_layout.png)

We need two utilities to use this string format. A function to build a world from the string and another to assert a world against a given world string. For many of the movement-related tests is the only assertion we need! Compare the following examples, which do you find easier to reason about?

```csharp
[Test]
void TestPlayerMovesForward_ThenIsBlocked_WithLayout() {
  var map = @"
XXX -X-
XXX ---
XXX -P-
";
  World world = CreateWorld(map);
  /* ... move player forward ... */
  AssertWorldMatches(world, @"
XXX -X-
XXX -P-
XXX ---
");
  /* ... move player forward again ... */
  AssertWorldMatches(world, @"
XXX -X-
XXX -P-
XXX ---
");
}

[Test]
void TestPlayerMovesForward_ThenIsBlocked_WithoutLayout() {
  var world = CreateWorld();
  world.PlaceFloor();
  world.PlaceWall(new Vector3Int(1, 1, 2));
  world.PlacePlayer(new Vector3Int(1, 1, 0));
  /* ... move player forward ... */
  AssertPlayerPosition(world, new Vector3Int(1, 1, 1));
  /* ... move player forward again ... */
  AssertPlayerPosition(world, new Vector3Int(1, 1, 1));
}
```


If you're still not convinced, consider what the test failure messages would look like:

```
Expected:
XXX -X-
XXX -P-
XXX ---

Actual:
XXX -X-
XXX ---
XXX -P-
```

Versus:

```
Expected player at (1, 1, 1), instead found (1, 1, 0)
```

The difference here isn't extreme but it scales well when we add multiple pathfinding enemies into the mix.

## Implementation

The map layout string can be build up from a few components. A parser to parse the string into a 3D array, an axis transformer, and a lookup table of game entity factories. 

### Parser

The parser is relatively simple, consisting of a few successive Split commands:

```csharp
char[][][] ParseLayoutString(string layoutString){
  string[]   byLine = layoutString.Split("\n");
  string[][] byLineThenLayer = byLine
    .Select(line => 
      line.Split(" ")
    ).ToArray();
  
  char[][][] byLineThenLayerThenChar = byLineThenLayer
    .Select(line => 
      line.Select(lineLayer => 
        lineLayer.ToCharArray()
      ).ToArray();
    ).ToArray();
  
  return byLineThenLayerThenChar;
}
```

Done! Before we move on, consider the indexes we need to access the `i` in this layout:

```
abc def gih
jkl mno pqr
stu vwx yz0
```

Its indexed by line first, then by each layer in the line, then by the character order inside each segment. So we'd need something like `charArray[0][2][1]` . This definitely isn't in x, y, z order.

### Axis transformer

So we'd like to get an array we can access with Unity's axis layout, in (x, y, z) order. We could use unity's Matrix4x4 to do this for us, once we found the correct combination of flips and rotations. I decided to home bake a utility specifically for re-ordering and flipping axises. This is roughly how we'll get the layout we need:

```csharp
Array3D<char> TransformLayout(Array3D<char> input) {
  DimensionalityTransform transformation = GetDefaultCoordinateTransform();

  var newLayoutSize = transformation.Transform(input.GetSize());
  var output = new Array3D<char>(size: newLayoutSize);

  foreach (var outputCoordinate in AllCoordinatesInside(newLayoutSize)) {
    var inputCoordinate = transformation.InverseTransform(outputCoordinate);

    var inputTile = input[inputCoordinate];
    output[outputCoordinate] = inputTile;
  }

  return output;
}
```

For this specific layout we want our DimensionalityTransform to look something like this: `[-Z][+Y][+X]` . This will end up with a layout where:
- Z points up (lines are ordered from top down, so we need to invert)
- X points left (char arrays are already ordered left to right)
- Y points left across the layers

```
Z
11 11
00 00

X
01 01
01 01

Y
00 11
00 11
```

### Lookup table

From here, we need a way to map a single character to a way to create something at that location. In C#, we can use the `Func<>` type for this. So we'll build something like a `Dictionary<char, Func<Vector3Int, IEntity>>` , and invoke the Func pointed to by each character at each position. With simplified code:

```csharp
World BuildWorld(Array3D<char> xyzLayout, Dictionary<char, Func<Vector3Int, IEntity>> tileFactories) {
  World world = new World(xyzLayout.Size);

  foreach (Vector3Int coordinate in AllCoordinatesInside(xyzLayout.Size)) {
    char atLocation = xyzLayout[coordinate];

    if (tileFactories.TryGetValue(atLocation, out var factoryFunction)){
      IEntity createdEntity = factoryFunction(coordinate);
      world = world.AddEntity(createdEntity);
    }
  }

  return world;
}

Dictionary<char, Func<Vector3Int, IEntity>> GetDefaultFactories(){
  return new Dictionary<char, Func<Vector3Int, IEntity>>(){
    {'X', CreateWall   },
    {'P', CreatePlayer },
  }

}
IEntity CreatePlayer(Vector3Int location) { /* ... */ }
IEntity CreateWall  (Vector3Int location) { /* ... */ }
```

We can chain these 3 components together to get our world builder working! To get a world assertion working from here, we can supplement the factory functions. For my purposes, I use a hard type-check: a `P` verifies there is an entity at that position of exact type `Player`. One can imagine attaching more complex assertions to those characters, in the same way that we attach factory functions to them. For example asserting based on a string tag match or the presence of a specific interface.

This gives us all the tools we need to build our world from a layout string, and assert against it! This approach can be adapated into the test harness for any kind of grid-based game. We only need a couple things from our world implementation to attach this harness to it:
1. Create an entity at a specific grid location, when building the world
2. Get entities at a specific grid location, when asserting agains the world.

In theory we could even use this with GameObjects as long as they were at grid-aligned positions!

# Command Pattern

The other useful components of these tests are the command pattern and immutable objects. To some degree this is optional, but I find that these approaches fit together very well in practice. The command pattern helps manage the entry-points into the system, so games with smaller interfaces wouldn't need to go this far. The story is similar for usage of immutability: there is significant developement and performance overhead to implementing immutable data structures. But it forces many good practices which pay of when building something complex.

I'll demonstrate some of these advantages via examples as best I can; focusing on the command pattern. Immutability is less relevant to the tests themselves and more about how the code under test is arranged.

We see usage of the command pattern via the helper struct `MovementCommands` which contains a set of commonly used commands. For example, `mv.jump == DungeonCommandFactory.JumpEntity(id) == new JumpCommand(id)` . We see evidence of immutability in the repeated use of `World = World`, keeping the `World` field up-to-date with all commands.

## Goal

In our tests, the command pattern will isolate our tests from most changes in our game logic. We would like to reference only a Factory and the ICommand interface instead of referencing any methods directly on the game entities. I'll start with a comparitive example:

```csharp
[Test]
void TestPlayerMovesForward_WithCommands() {
  World world = /* ... create world ... */;
  EntityId playerId = world.GetSingleAt(new Vector3Int(1, 1, 0));
  ICommand moveForwardCommand = CommandFactory.MoveForward(playerId, 1);
  world = world.ApplyCommand(moveForwardCommand);
  /* ... assert movement occurred ... */
}

[Test]
void TestPlayerMovesForward_WithoutCommands() {
  World world = /* ... create world ... */;
  EntityId playerId = world.GetSingleAt(new Vector3Int(1, 1, 0));
  Player player = world.GetEntity(playerId);
  player.MoveForward(1);
  /* ... assert movement occurred ... */
}
```


Note that the tests which rely on Commands enjoy a greater separation of concerns. The test case code itself depends on shared types: `World`, `EntityId`, and `ICommand`. As well as components of the test harness via `CommandFactory`. This is an indicator that this test case may be much more maintainable.

## Implementation

To set up our command pattern we will start with a foundation of various interfaces. The command implementation itself becomes much clearer after we define the interfaces it has to work with.

### The Interfaces

We'll have several interfaces. Most of these describe how the command's implementation interacts with the world, and finally the interface which the command itself must conform to:

```csharp
interface IWorldWriter {
  IEntity GetEntity(EntityId id);
  void SetEntity(EntityId id, IEntity newEntity);
}
interface IPathingWorld {
  bool IsBlocked(Vector3Int position);
}
interface IHavePosition {
  Vector3Int GetPosition();
  IEntity WithPosition(Vector3Int newPosition);
}
interface IEntity {}

interface ICommand {
  void Execute(IWorldWriter writer);
}
```

### The implementation

Now we can implement our command. The `MoveForwardCommand` should hold all the logic related to moving and being blocked by walls.

```csharp

class MoveForwardCommand : ICommand {
  public int distance;
  public EntityId targetEntityId;
  public void Execute(IWorldWriter worldWriter) {
    IEntity targetEntity = worldWriter.GetEntity(targetEntityId);
    IHavePosition entityWithPosition = targetEntity as IHavePosition;
    if (entityWithPosition == null) throw new InvalidOperationException("Attempted to move an entity which does not have a position");

    Vector3Int newPosition = MoveForwardFrom(entityWithPosition.GetPosition(), worldWriter.pathingData);

    IEntity newEntity = entityWithPosition.WithPosition(newPosition);
    worldWriter.SetEntity(targetEntityId, newEntity);
  }
  private Vector3Int MoveForwardFrom(Vector3Int position, IPathingWorld pathing) {
    /* ... implement moving forward, blocked by walls, this.distance steps ... */
  }
}
```

Really anything could be inside this command, depending on the game's specific implementation. Importantly it can be constructed from only very basic types: an `int` and a custom `EntityId` type. All of the commands should be constructed from simple serializable types such as this. 

### Aside - benefits of Commands in the game

Lets have a brief look at what commands can do in a game's implementation. In this example we use commands to represent user input directly rather than making method calls inside the input manager itself! This allowed us to trivially implement input queuing:

```csharp
class InputManager: MonoBehavior{
  private World _world;          // set on Start
  private EntityId _playerId;    // set after world initialization
  private KeyCode _dashKey = KeyCode.Shift;
  private Queue<ICommand> _queuedCommands;
  void Update() {
    var inputCommand = GetInputCommand();
    if (inputCommand != null) {
      _queuedCommands.Enqueue(inputCommand);
    }

    if (_world.IsUpdating && _queuedCommands.Count > 0){
      ICommand nextCommand = _queuedCommands.Dequeue();
      _world = _world.ApplyCommand(nextCommand);
    }
  }

  ICommand? GetInputCommand() {
    if (Input.KeyDown(this._dashKey)) {
      return new MoveForwardCommand() {
        distance = 2,
        targetEntityId = this._playerId
      };
    }
    return null;
  }
}
```

One can imagine a many options unlocked by serializable commands, including:
- Input queueing
- Passing commands over the network
- Saving commands in a local file
- Replaying a recorded series of commands to acheive identical world state
- Inspecting commands in other parts of the system with listeners. For example, triggering a sword animation after an AttackCommand listener triggered

# Tying it all together

To tie together the map layout and commands, I'll use a real-world test right out of Gobbies Stole My Ruins:

```csharp
[Test]
public void WhenPlayerJumps_ThenDashesOverGap_MovesOverGap()
{
    // arrange
    var map = @"
XXX XXX ---
XXX --- ---
XXX -P- ---
";
    CreateWorld(map);
    // places the dash and jump items into the players inventory
    EnableDash();
    EnableJump();
    EntityId playerId = GetSingle<Player>();
    var mv = new MovementCommands(playerId);
    AssertPosition(playerId, 1, 1, 0, FacingDirection.North);
    
    // act + assert
    World = World
        .ApplyCommandsAndTick(mv.jump);
    AssertWorldMatches(@"
XXX XXX ---
XXX --- ---
XXX --- -P-
");
    
    World = World
        .ApplyCommandsAndTick(mv.dash);
    AssertWorldMatches(@"
XXX XXX -P-
XXX --- ---
XXX --- ---
");
}
```

So, this is what we get by combining all these techniques together. In my opinion this is everything we need it to be:
- Highly maintainable because the test has no direct dependencies on implementation details 
- Easy to read thanks to the map layout strings

In the future, I hope to build a shareable library around these concepts! I'll make another blog post at that point. Hopefully after I've battle-tested it in a few more game jams. Thanks for reading!

